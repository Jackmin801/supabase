import Layout from '~/layouts/DefaultGuideLayout'
import {CodeBlock, Admonition, Accordion} from 'ui'

export const meta = {
  id: 'auth-postgres-hooks',
  title: 'Auth Hooks (Postgres)',
  description: 'Use Supabase Postgres Functions to customize your authentication flow',
}

<Admonition type="info">
Hooks are in beta. They will be available for all projects in early 2024.
</Admonition>


Supabase allows you to use PostgreSQL functions to alter the default Supabase Auth flow. Developers can use hooks to add custom behavior that's not supported natively.

Hooks help you:

- Track the origin of user signups by adding metadata
- Improve security by adding additional checks to password and multi-factor authentication
- Support legacy systems by integrating with identity credentials from external authentication systems
- Add additional custom claims to your JWT


You can use hooks at specific points along an Auth flow to perform custom behavior via Postgres Functions. These are known as **extensibility points**. The following extensibility points are available:

| Extensibility Point              | Available on Plan       |
|----------------------------------|-------------------------|
| MFA Verification Attempt         | Teams and Enterprise    |
| Password Verification Attempt    | Teams and Enterprise    |
| Custom Access Token              | Free                    |

You can link a hook to an extensiblity point to signal to Supabase Auth that it should make use of the hook.


Below is a flow chart illustrating how Supabase Auth uses an Auth Hook:

<Image
  alt="Auth Hooks Flowchart"
  src="/docs/img/guides/auth-postgres-hooks/hooks-flowchart.png"/>


## Creating and managing Hooks
### Writing a Hook

In the dashboard, go to `SQL Editor > Templates` and select `Add Auth Hook (General)`. The function for your hook should look like this:

```sql
create or replace function
mfa_verification_attempt(event jsonb) returns jsonb as $$
declare
  -- Add your variables here
begin
  -- Add your logic here
  return response
end;
$$ language plpgsql;
```

Note that the JSONB operator `?` can't be used when writing a hook, because it is a reserved character in the ORM used by Supabase Auth.

### Handling Hook errors

Unless otherwise specified, your hook should return errors with the following fields:

- `error` An object that contains information about the error.
    - `http_code` A number indicating the HTTP code to be returned. If not set, the code is HTTP 500 Internal Server Error.
    - `message` A message to be returned in the HTTP response. Required.

You should return an error if an input in the `event` payload has been processed incorrectly. This error could result from a server error (for example, an unexpected error with the data) or a user error (for example, the user has exceeded the number of available attempts).

In general, Supabase Auth ignores all fields other than the `error` field attached to the returned JSON.

Example output:
```jsx
{
  "error": {
    "http_code": 429,
    "message": "You can only verify a factor once every 10 seconds."
  }
}
```

### Assigning Hook permissions

You need to assign additional permissions to the hook and the tables that it interacts with.

By default, Supabase Auth invokes hooks with the `supabase_auth_admin` role. This role doesn't have permissions to modify the `public` schema. You need to grant the role permission to execute your hook function:

```sql
grant execute
  on function public.custom_access_token_hook
  to supabase_auth_admin;
```

Also revoke permissions from the `authenticated` and `anon` roles to ensure the function is not accessible by Supabase Serverless APIs.

```sql
revoke execute
  on function public.custom_access_token_hook
  from authenticated, anon;
```

<Admonition type="caution">
Avoid adding a `security definer` tag to the function to avoid permission errors.
</Admonition>

At time of writing, Postgres functions have an implicit tag of `security invoker` and run with the permissions of the calling user. In the case of Auth Hooks, `supabase_auth_admin`  is the invoker and hook functions run with the permissions of `supabase_auth_admin`.

The `security definer` tag executes a function with the privileges of the user who owns it.  In the case of functions created via the Supabase Dashboard, this user is `postgres`, which does not have permissions for the Auth schema. Using `security definer` tag would prevent Supabase Auth from having the appropriate permissions to access tables or execute functions.


### Timeouts

Ensure that your hooks complete within **2 seconds** to avoid any errors.



### Connecting the Hook

In the dashboard, navigate to [`Authentication > Hooks (Beta)`](/dashboard/project/_/auth/hooks) and select the appropriate PostgreSQL function from the dropdown menu.


## MFA Verification Attempt Extensibility Point

You can add additional checks to the [Supabase MFA implementation](/docs/guides/auth/auth-mfa) with hooks. For example, you can:

- Limit the number of verification attempts performed over a period of time.
- Sign out users who have too many invalid verification attempts.
- Count, rate limit, or ban sign-ins.

**Inputs**

Supabase Auth will supply the following fields to your hook:

- `factor_id` Unique identifier for the MFA factor being verified. 
- `user_id` Unique identifier for the user.
- `valid` Whether the verification attempt was valid. For TOTP, this means that the six digit code was correct (true) or incorrect (false).

Example payload:

```json
{
	"factor_id": "6eab6a69-7766-48bf-95d8-bd8f606894db",
	"user_id": "3919cb6e-4215-4478-a960-6d3454326cec",
	"valid": true,
}
```

**Outputs**

Return this if your hook processed the input without errors.

- `decision` A string containing the decision on whether to allow authentication to move forward. Use `reject` to deny the verification attempt and log the user out of all active sessions. Use `continue` to use the default Supabase Auth behavior.
- `message` The message to show the user if the decision was `reject`.

Example output:

```json
{
   "decision": "reject",
   "message" : "You have exceeded maximum number of MFA attempts."
}
```
**Examples**
<Tabs
  scrollable
  size="small"
  type="underlined"
  defaultActiveId="js"
  queryGroup="language"
>
<TabPanel id="limit-failed-mfa-verification-attempts" label="Limit Failed MFA Verification Attempts">

Imagine that your company requires that a user can input an incorrect MFA Verification code no more than once every 2 seconds.

#### Database Setup

Create a table to record the last time a user had an incorrect MFA verification attempt for a factor.

```sql
create table public.mfa_failed_verification_attempts (
  user_id uuid not null,
  factor_id uuid not null,
  last_failed_at timestamp not null default now(),
  primary key (user_id, factor_id)
);
```

Create a hook to read and write information to this table. For example:

```sql
create function public.hook_mfa_verification_attempt(event jsonb)
  returns jsonb
  language plpgsql
as $$
  declare
    last_failed_at timestamp;
  begin
    if event->'valid' is true then
      -- code is valid, accept it
      return jsonb_build_object('decision', 'continue');
    end if;

    select last_failed_at into last_failed_at
      from public.mfa_failed_verification_attempts
      where
        user_id = event->'user_id'
          and
        factor_id = event->'factor_id';

    if last_failed_at is not null and now() - last_failed_at < interval '2 seconds' then
      -- last attempt was done too quickly
      return jsonb_build_object(
        'error', jsonb_build_object(
          'http_code', 429,
          'message',   'Please wait a moment before trying again.'
        )
      );
    end if;

    -- record this failed attempt
    insert into public.mfa_failed_verification_attempts
      (
        user_id,
        factor_id,
        last_refreshed_at
      )
      values
      (
        event->'user_id',
        event->'factor_id',
        now()
      )
      on conflict do update
        set last_refreshed_at = now();

    -- finally let Supabase Auth do the default behavior for a failed attempt
    return jsonb_build_object('decision', 'continue');
  end;
$$;

-- Assign appropriate permissions and revoke access
grant execute
  on function public.hook_mfa_verification_attempt
  to supabase_auth_admin;

grant all
  on table public.mfa_failed_verification_attempts
  to supabase_auth_admin;

revoke execute
  on function public.hook_mfa_verification_attempt
  from authenticated, anon;

revoke all
  on table public.mfa_failed_verification_attempts
  from authenticated, anon;
```
</TabPanel>
<TabPanel id="send-email-after-failed-attempts" label="Send Email After Failed Verification Attempts">

Enable the `pg_net` extension under [`Database > Extensions`](/dashboard/project/_/database/extensions)

Create a table to record the last time a user had an incorrect MFA verification attempt for a factor.

```sql
create table public.mfa_failed_verification_attempts (
  user_id uuid not null,
  factor_id uuid not null,
  last_failed_at timestamp not null default now(),
  primary key (user_id, factor_id)
);
```
Create a hook to send an email when there are two or more failed attempts in a one minute window.

```sql
create or replace function public.hook_mfa_verification_attempt_with_email(event jsonb)
returns jsonb
language plpgsql
as $$
  declare
    last_failed_at timestamp;
    server_token text;
    email_address text;
    email_body text;
    response jsonb;
    http_code int;
    error_message text;
  begin
    -- check if the code is valid
    if event->'valid' is true then
      -- code is valid, accept it
      return jsonb_build_object('decision', 'continue');
    end if;

    -- fetch the server token with a specific name from the vault.decrypted_secrets table
    select token into server_token
    from vault.decrypted_secrets
    where name = 'yoursecretname';

    -- make sure we have a token
    if server_token is null then
      return jsonb_build_object(
        'error', jsonb_build_object(
        'http_code', 401,
        'message', 'Valid server token required'
      ));
    end if;

    -- fetch the last failed attempt time
    select last_failed_at into last_failed_at
    from public.mfa_failed_verification_attempts
    where user_id = event->>'user_id'
    and factor_id = event->>'factor_id';

    -- check if the last attempt was too quick
    if last_failed_at is not null and now() - last_failed_at < interval '1 minute' then
      -- construct the email body
      email_address := (select email from auth.users where id = (event->>'user_id')::uuid);
      -- Insert your email here
      email_body := format('{"from": "yoursenderemail@example.com",
                             "to": "%s",
                             "subject": "too many mfa attempts",
                             "textbody": "there have been too many mfa attempts.",
                             "htmlbody": "<html><body><strong>alert:</strong> too many mfa attempts.</body></html>",
                             "messagestream": "outbound"}', email_address);

      -- perform the http post request. Here we assume you are using Postmark as an email provider.
      select net.http_post(
        'https://api.postmarkapp.com/email',
        email_body,
        'application/json',
        array['accept: application/json', 'x-postmark-server-token: ' || server_token]
      ) into response;

      -- extract http code and error message if any
      http_code := (response ->> 'status')::int;
      error_message := response ->> 'message';

      -- return an error if the email sending fails
      if (response -> 'status' is null) or (http_code < 200 or http_code >= 300) then
        return jsonb_build_object(
          'error', jsonb_build_object(
            'http_code', coalesce(http_code, 0),
            'message', coalesce(error_message, 'error sending email')
          ));
      end if;

      return jsonb_build_object(
        'error', jsonb_build_object(
          'http_code', 429,
          'message', 'please wait a moment before trying again.'
        ));
      end if;

      -- record the failed attempt
      insert into public.mfa_failed_verification_attempts
      (
          user_id,
          factor_id,
          last_refreshed_at
      )
      values
      (
          event->'user_id',
          event->'factor_id',
          now()
      )
      on conflict (user_id, factor_id)
      do update
          set last_refreshed_at = now();

      -- let supabase auth do the default behavior for a failed attempt
      return jsonb_build_object('decision', 'continue');
  end;
$$;

-- assign appropriate permissions and revoke access
grant execute on function public.hook_mfa_verification_attempt_with_email to supabase_auth_admin;

grant all on table public.mfa_failed_verification_attempts to supabase_auth_admin;

revoke execute on function public.hook_mfa_verification_attempt_with_email from authenticated, anon;

revoke all on table public.mfa_failed_verification_attempts from authenticated, anon;
```

</TabPanel>
</Tabs>

## Password Verification Attempt Extensibility Point

Imagine that you wish to increase security beyond the requirements of the default password implementation in order to fulfill security or compliance requirements.

As this hook runs on unauthenticated requests, malicious users can abuse the hook by calling it multiple times.  Pay extra care when using the hook as you can unintentionally block legitimate users from accessing your application.

Check if a password is valid prior to taking any additional action to ensure the user is legitimate. Instead of blocking further verification attempts, consider sending an email or notification to an administrator via a trigger instead.

**Inputs**

- `user_id` Unique identifier for the user attempting to sign in. Correlate this to the `auth.users` table.
- `valid` Whether the password verification attempt was valid.

```json
{
	"user_id": "3919cb6e-4215-4478-a960-6d3454326cec",
	"valid": true,
}
```

**Outputs**

Return these only if your hook processed the input without errors.

- `decision` A string containing the decision whether to allow authentication to move forward. Use `reject` to completely reject the verification attempt and log the user out of all active sessions. Use `continue` to use the default Supabase Auth behavior.
- `message` The message to show the user if the decision was `reject`.
- `should_logout_user` Whether to logout a user if a `reject` decision is issued. Has no effect when a `continue` decision is issued.

Example output:

```json
{
   "decision": "reject",
   "message" : "You have exceeded maximum number of password Sign-In attempts.",
   "should_logout_user": "false"
}
```

**Examples**

<Tabs
  scrollable
  size="small"
  type="underlined"
  defaultActiveId="js"
  queryGroup="language"
>
<TabPanel id="limit-failed-password-verification-attempts" label="Limit Failed Password Verification Attempts">

As part of new security measures within the company, users can only input an incorrect password every 10 seconds and not more than that. You want to write a hook to enforce this.

#### Database Setup

Create a table to record each user's last incorrect password verification attempt.

```sql
create table public.password_failed_verification_attempts (
  user_id uuid not null,
  last_failed_at timestamp not null default now(),
  primary key (user_id)
);
```

Create a hook which to read and write information to this table. For example:

```sql
create function public.hook_password_verification_attempt(event jsonb)
returns jsonb
language plpgsql
as $$
  declare
    last_failed_at timestamp;
  begin
    if event->'valid' is true then
      -- password is valid, accept it
      return jsonb_build_object('decision', 'continue');
    end if;

    select last_failed_at into last_failed_at
      from public.password_failed_verification_attempts
      where
        user_id = event->'user_id';

    if last_failed_at is not null and now() - last_failed_at < interval '10 seconds' then
      -- last attempt was done too quickly
      return jsonb_build_object(
        'error', jsonb_build_object(
          'http_code', 429,
          'message',   'Please wait a moment before trying again.'
        )
      );
    end if;

    -- record this failed attempt
    insert into public.password_failed_verification_attempts
      (
        user_id,
        last_failed_at
      )
      values
      (
        event->'user_id',
        now()
      )
      on conflict do update
        set last_failed_at = now();

    -- finally let Supabase Auth do the default behavior for a failed attempt
    return jsonb_build_object('decision', 'continue');
  end;
$$;

-- Assign appropriate permissions
grant execute
  on function public.hook_password_verification_attempt
  to supabase_auth_admin;

grant all
  on table public.password_failed_verification_attempts
  to supabase_auth_admin;

revoke execute
  on function public.hook_password_verification_attempt
  from authenticated, anon;

revoke all
  on table public.password_failed_verification_attempts
  from authenticated, anon;
```
</TabPanel>
<TabPanel id="send-email-on-first-password-login" label="Send Email On First Password Login">

Your company wishes to send out a welcome email to users on the first time they login via email and password.

Create a table to track sign in attempts. We refrain from using the `auth.users` table's `last_signed_in_at` field as it includes successful OAuth and magic link sign ins.

```sql
create table public.password_sign_in_attempts (
  user_id uuid not null,
  attempt_id uuid not null,
  last_attempt_at timestamp not null default now(),
  attempt_successful boolean not null,
  primary key (user_id, attempt_id)
);
```

```sql
create or replace function public.hook_send_welcome_email(event jsonb)
returns jsonb
language plpgsql
as $$
  declare
    user_id uuid;
    server_token text;
    email_address text;
    email_body text;
    response jsonb;
    http_code int;
    error_message text;
    attempt_count int;
  begin
    user_id := (event->>'user_id')::uuid;

    -- check if the password verification is valid
    if event->'valid' is true then
      -- Check the number of previous attempts
      select count(*) into attempt_count
      from public.password_sign_in_attempts
      where user_id = user_id;

      -- If it's the first successful login, send a welcome email
      if attempt_count = 0 then
        -- Fetch the server token and email address
        select token into server_token from vault.decrypted_secrets where name = 'yoursecretname';
        select email into email_address from auth.users where id = user_id;

        -- Construct the welcome email body
        email_body := format('{"from": "yoursenderemail@example.com",
                               "to": "%s",
                               "subject": "Welcome to Our Service",
                               "textbody": "Welcome! Thank you for joining our service.",
                               "htmlbody": "<html><body><strong>Welcome!</strong> Thank you for joining our service.</body></html>",
                               "messagestream": "outbound"}', email_address);

        -- Perform the HTTP POST request using Postmark
        select net.http_post(
          'https://api.postmarkapp.com/email',
          email_body,
          'application/json',
          array['accept: application/json', 'x-postmark-server-token: ' || server_token]
        ) into response;

        -- Extract HTTP code and error message, if any
        http_code := (response ->> 'status')::int;
        error_message := response ->> 'message';

        -- Handle email sending errors
        if (response -> 'status' is null) or (http_code < 200 or http_code >= 300) then
          return jsonb_build_object(
            'error', jsonb_build_object(
              'http_code', coalesce(http_code, 0),
              'message', coalesce(error_message, 'error sending email')
            ));
        end if;
      end if;
    end if;

    -- Record the attempt, successful or not
    insert into public.password_sign_in_attempts (user_id, attempt_id, last_failed_at)
    values (user_id, (event->>'attempt_id')::uuid, now())
    on conflict (user_id, attempt_id)
    do update set last_failed_at = now();

    -- Continue with default behavior
    return jsonb_build_object('decision', 'continue');
  end;
$$;

-- Assign appropriate permissions
grant execute
  on function send_welcome_email
  to supabase_auth_admin;

revoke execute
  on function public.send_welcome_email
  from authenticated, anon;

grant all
  on table public.password_verification_attempts
  to supabase_auth_admin;

revoke all
  on table public.password_verification_attempts
  from authenticated, anon;
```
</TabPanel>
</Tabs>

## Custom Access Token Extensibility Point

The custom access token hook runs before a token is issued and allows you to add additional claims based on the authentication method used or add additional metadata to select users.

Claims returned must conform to our specification. Supabase Auth will check for these claims after the hook is run and return an error if they are not present.

These are the fields currently available on an access token:

| Field           | Required |
|-----------------|-------------------|
| `aud`           | Yes               |
| `exp`           | Yes               |
| `jti`           | No                |
| `iat`           | Yes               |
| `iss`           | No                |
| `nbf`           | No                |
| `sub`           | Yes               |
| `email`         | Yes               |
| `phone`         | Yes               |
| `app_metadata`  | No                |
| `user_metadata` | No                |
| `role`          | Yes               |
| `aal`           | Yes               |
| `amr`           | No                |
| `session_id`    | No                |


**Inputs**

- `user_id` Unique identifier for the user attempting to sign in. Correlate this to the `auth.users` table.
- `claims` Claims which are attached to the access token.
- `authentication_method` the authentication method used to request the access token. Possible values include:
`oauth`, `password`, `otp`, `totp`, `recovery`, `invite`, `sso/saml`, `magiclink`, `email/signup`, `email_change`, `token_refresh`.



**Outputs**

Return these only if your hook processed the input without errors.

- `claims` A json containing the updated claims after the hook has been run.

**Examples**

<Tabs
  scrollable
  size="small"
  type="underlined"
  defaultActiveId="js"
  queryGroup="language"
>
<TabPanel id="add-admin-role" label="Add Admin Role">

Your company would like to allow registered admin users to perform restricted actions by granting an `admin` claim to their token.

Create a profiles table with an `is_admin` flag:

```sql
create table profiles (
  user_id uuid not null primary key references auth.users (id),
  email text not null unique,
  is_admin boolean not null default false
);
```

Create a hook which adds an additional role based on the `is_admin` flag:

```sql
create or replace function public.custom_access_token_hook(event jsonb)
returns jsonb
language plpgsql
as $$
  declare
    claims jsonb;
    is_admin boolean;
  begin
    -- Check if the user is marked as admin in the profiles table
    select is_admin into is_admin from profiles where user_id = event->>'user_id';

    -- Proceed only if the user is an admin
    if is_admin then
      claims := event->'claims';

      -- Check if 'user_metadata' exists in claims
      if jsonb_typeof(claims->'user_metadata') is null then
        -- If 'user_metadata' does not exist, create an empty object
        claims := jsonb_set(claims, '{user_metadata}', '{}');
      end if;

      -- Set a claim of 'admin'
      claims := jsonb_set(claims, '{user_metadata, admin}', 'true');

      -- Update the 'claims' object in the original event
      event := jsonb_set(event, '{claims}', claims);
    end if;

    -- Return the modified or original event
    return event;
  end;
$$;

grant execute
  on function public.custom_access_token_hook
  to supabase_auth_admin;

revoke execute
  on function public.custom_access_token_hook
  from authenticated, anon;
```
</TabPanel>

<TabPanel id="delete-usermetadata-claim" label="Delete Claims">
Your company would like to remove the user metadata claim in order to reduce the size of your access token.

```sql
create or replace function custom_access_token_delete_user_metadata(input jsonb)
returns jsonb as $$
  declare
    result jsonb;
  begin
    input := jsonb_set(input, '{claims}', (input->'claims') - 'user_metadata');
    result := jsonb_build_object('claims', input->'claims');
    return result;
  end;
$$ language plpgsql;

grant execute
  on function public.custom_access_token_delete_user_metadata
  to supabase_auth_admin;

revoke execute
  on function public.custom_access_token_delete_user_metadata
  from authenticated, anon;
```
</TabPanel>
<TabPanel id="add-metadata-claim-plv8" label="Add Claim Via PLV8">
Your company runs a new version of a gamification app and would like to add a `level` claim to the access token. We fetch the level of an existing user from the `profiles` table and assign new users a default level of zero.

Enable the `plv8` extension under [`Database > Extensions`](/dashboard/project/_/database/extensions)

```javascript
create or replace function custom_access_token_hook(event jsonb)
returns jsonb
language plv8
as $$
  var user_level;

  // Fetch the current user's level from the profiles table
  var result = plv8.execute("select level from profiles where user_id = $1", [event.user_id]);
  if (result.length > 0) {
    user_level = result[0].level;
  } else {
    // Assign a default level of 0 if no level is found
    user_level = 0;
  }

  // Check if 'claims' exists in the event object; if not, initialize it
  if (!event.claims) {
    event.claims = {};
  }

  // Update the level in the claims
  event.claims.level = user_level;

  return event;
$$;
```
</TabPanel>

</Tabs>



export const Page = ({ children }) => <Layout meta={meta} children={children} />
export default Page
