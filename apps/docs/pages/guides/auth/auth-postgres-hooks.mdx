import Layout from '~/layouts/DefaultGuideLayout'
import {CodeBlock, Admonition, Accordion} from 'ui'

export const meta = {
  id: 'auth-postgres-hooks',
  title: 'Auth Hooks (Postgres)',
  description: 'Use Supabase Postgres Functions to customize your authentication flow',
}

<Admonition type="info">
Hooks are currently in beta and will only be available on all projects early 2024.
</Admonition>


Supabase allows you to use PostgreSQL functions to alter the default Supabase Auth flow. Developers can use hooks to write custom behaviour when there are no built-in ways of achieving the desired behavior.

Hooks might help you:

- Track the origin of user signups by adding metadata
- Improve security by adding additional checks to password and multi-factor authentication
- Support legacy systems by integrating with identity credentials from external authentication systems
- Add additional custom claims to your JWT


You can use hooks at specific points along an Auth flow to perform custom behavior via PostgreSQL Functions. These are known as **extensibility points**. Currently, the following extensibility points are available:

| Extensibility Point              | Available on Plan       |
|----------------------------------|-------------------------|
| MFA Verification Attempt         | Teams and Enterprise    |
| Password Verification Attempt    | Teams and Enterprise    |
| Custom Access Token              | Free                    |

You can link a hook to an extensiblity point to signal to Supabase Auth that it should make use of the hook.


Below is a flow chart illustrating how Supabase Auth uses an Auth Hook:

<Mermaid
 chart={`flowchart TD
    subgraph Supabase Auth
    Start[Event Occurs] --> DecisionA{Is a Hook defined?}

    ValidityCheck --Yes-->ContinueFlow[Continue with flow]
    ValidityCheck --No-->Error(Return Error)

    DecisionA -- No ---->H[Continue with Supabase Default Behavior]
    H--> ValidityCheck{Is response valid?}
    DecisionA --Yes--->ValidateInput((Validate Inputs))
        ValidateOutput -->ContinueFlow
    end



    subgraph Auth Hook
    ValidateInput ---->CallHook[Execute PostgreSQL Function]

    CallHook ---> ValidateOutput((Validate Outputs))
    end`}
    />


## Creating and Managing Hooks
### Writing a Hook

Head to the `SQL Editor > Templates` and select `Add Auth Hook (General)`. Here is an example of what a function outline for the Hook would look like:

```sql
create
or replace function mfa_verification_attempt(event jsonb) returns jsonb as $$
declare
    -- Add your variables here
begin
	-- Add your logic here
  return response
end;
$$ language plpgsql;
```

Note that the JSONB operator `?` cannot currently be used when writing a hook as it is a reserved character in the ORM used by Supabase Auth.

### Handling Hook errors

Unless otherwise specified, hooks return errors with the following fields:

- `error` An object that contains information about the error.
    - `http_code` A number indicating the HTTP code to be returned. If not set, the code is HTTP 500 Internal Server Error.
    - `message` A message to be returned in the HTTP response. Must be set.

You should return an error if an input in the `event` payload has been processed incorrectly. This error could result from a server error (e.g. An unexpected error with the data) or a user error (e.g. the user has exceeded the number of available attempts).

In general, Supabase Auth will ignore all fields other than the `error` field attached to the returned JSON.

Example output:
```jsx
{
  "error": {
    "http_code": 429,
    "message": "You can only verify a factor once very 10 seconds."
  }
}
```

### Assigning Hook Permissions

You will need to assign additional permissions to the hook as well as the tables that it will interact with.

By default, Supabase Auth will invoke a hook with the `supabase_auth_admin` role and the `supabase_auth_admin` role does not have permissions to modify the `public` schema - you will need to grant the role additional permissions to execute the function you have defined:

```sql
grant execute
	on function public.custom_access_token_hook
	to supabase_auth_admin;
```

Also revoke permissions from the `authenticated` and `anon` roles to ensure the function is not accessible by Supabase Serverless APIs.

```sql
revoke execute
	on function public.custom_access_token_hook
	from authenticated, anon;
```

<Admonition type="warning">
Avoid adding a `security definer` tag to the function to avoid permission errors.
</Admonition>

At time of writing, Postgres functions have an implicit tag of `security invoker` and will run with the permissions of the user that calls it. In the case of Auth Hooks, `supabase_auth_admin`  is the invoker and it will run with the permissions of `supabase_auth_admin`.

The `security definer` tag specifies that the hook is to be executed with the privileges of the user that owns it.  In the case of functions created via the Supabase Dashboard this is `postgres` which does not have permissions over the Auth schema. Introducing a `security definer` tag could prevent Supabase Auth from having the appropriate permissions to access tables or execute functions.


### Timeouts

Hook timeouts are controlled by a `local` statement timeout scoped to the Postgres Function Hook. Ensure that your hooks complete within **2 seconds** to avoid any errors

### Testing the Hook

We strongly recommend testing the hook prior to going into production via [PgTAP](https://supabase.com/docs/guides/database/extensions/pgtap) or similar. You can enable the extension under `Database > Extensions > PgTAP`

Here's an example of what a `PgTAP` test could look like for an MFA Verification hook.

```sql
begin;
select plan (1);

-- table to store test results
create temporary table test_results (
  name text primary key
  , result boolean
  , debug text
);

-- function to record test result when run inside a block with vars
create or replace function tests.record_result(name text, result boolean, debug text DEFAULT NULL)
  returns void language plpgsql as $$
begin
  insert into test_results(name, result, debug) values (name, result, debug);
end;
$$;

do $$
  declare
     -- Arrange and setup any variables used in the test
    _user1 uuid = '00000000-0000-0000-0000-000000000001';
    _factor1 uuid = 'FFFFFFFF-FFFF-FFFF-FFFF-FFFFFFFFFFF1';
    _valid_user1_event jsonb = jsonb_build_object('user_id', _user1, 'factor_id', _factor1, 'valid', true);
    _invalid_user1_event jsonb = jsonb_build_object('user_id', _user1, 'factor_id', _factor1, 'valid', false);
    _result jsonb;
  begin
    set search_path to 'public';

    insert into auth.users(id) values (_user1);

    -- Act and run the function
    perform tests.record_result(
      'Valid event result'
      , (select hook_mfa_verification_attempt(_valid_user1_event)) ->> 'decision' = 'continue'
    );

    -- Add further test cases here
  end;
$$;

set search_path to 'extensions';

-- Assert that the desired result is received
select set_eq(
  $$ select name, result, debug from test_results $$,
  $$ select * from (values
    , ('Valid event result', true, null)
  ) as t $$,
  'MFA Auth hook tests:'
);

select * from finish();
rollback;
````


### Connecting the Hook

In the dashboard, navigate to `Authentication > Hooks (Beta)` and select the appropriate PostgreSQL function from the dropdown menu.
![Hooks UI](/docs/img/guides/auth-postgres-hooks/hooks-ui.png)


## MFA Verification Attempt Hook

You can add additional checks to the [Supabase MFA implementation](https://supabase.com/docs/guides/auth/auth-mfa) with hooks. For example, you can:

- Limit the number of verification attempts performed over a period of time.
- Sign out users who have too many invalid verification attempts.
- Count, rate limit, or ban sign-ins.

### Inputs

Supabase Auth will supply the following fields to your hook:

- `factor_id` Unique identifier for the MFA factor being verified. 
- `user_id` Unique identifier for the user.
- `valid` Whether the verification attempt was valid. For TOTP, this means that the six digit code was correct (true) or incorrect (false).

Example payload:

```json
{
	"factor_id": "6eab6a69-7766-48bf-95d8-bd8f606894db",
	"user_id": "3919cb6e-4215-4478-a960-6d3454326cec",
	"valid": true,
}
```

### Outputs

Return this if your hook processed the input without errors.

- `decision` A string containing the decision on whether to allow authentication to move forward. Use `reject` to deny the verification attempt and log the user out of all active sessions. Use `continue` to use the default Supabase Auth behavior.
- `message` The message to show the user if the decision was `reject`.

Example output:

```json
{
   "decision": "reject",
   "message" : "You have exceeded maximum number of MFA attempts."
}
```
### Example: Limit Failed MFA Verification Attempts
<Tabs
  scrollable
  size="small"
  type="underlined"
  defaultActiveId="js"
  queryGroup="language"
>
<TabPanel id="add-admin-role" label="Limit Failed MFA Verification Attempts">

Imagine that your company requires that a user can only input an incorrect MFA Verification code every 2 seconds and not more than that.

#### Database Setup

First you need to create a table that will record the last time a user had an incorrect MFA verification attempt for a factor.

You can do this by creating a table such as:

```sql
create table public.mfa_failed_verification_attempts (
  user_id uuid not null,
  factor_id uuid not null,
  last_failed_at timestamp not null default now(),
  primary key (user_id, factor_id)
);
```

Then you should create a hook which will read and enter information into this table. Example:

```sql
create function public.hook_mfa_verification_attempt(event jsonb)
returns jsonb
language plpgsql
as $$
		declare
			last_failed_at timestamp;
		begin
			if event->'valid' is true
			then
				-- code is valid, accept it
				return jsonb_build_object('decision', 'continue');
			end if;

			select last_failed_at into last_failed_at
				from public.mfa_failed_verification_attempts
				where
					user_id = event->'user_id'
						and
					factor_id = event->'factor_id';

			if last_failed_at is not null and now() - last_failed_at < interval '2 seconds'
			then
				-- last attempt was done too quickly
				return jsonb_build_object(
					'error', jsonb_build_object(
						'http_code', 429,
						'message',   'Please wait a moment before trying again.'));
			end if;

			-- record this failed attempt
			insert into public.mfa_failed_verification_attempts
				(
					user_id,
					factor_id,
					last_refreshed_at
				)
				values
				(
					event->'user_id',
					event->'factor_id',
					now()
				)
				on conflict
			do update
				set last_refreshed_at = now();

			-- finally let Supabase Auth do the default behavior for a failed attempt
			return jsonb_build_object('decision', 'continue');
		end;
	$$;

-- Assign appropriate permissions and revoke access
grant execute
	on function public.hook_mfa_verification_attempt
	to supabase_auth_admin;

grant all
	on table public.mfa_failed_verification_attempts
	to supabase_auth_admin;

revoke execute
	on function public.hook_mfa_verification_attempt
	from authenticated, anon;

revoke all
	on table public.mfa_failed_verification_attempts
	from authenticated, anon;
```
</TabPanel>
</Tabs>

## Password Verification Attempts Hook

Imagine that you wish to increase security beyond the requirements of the default password implementation in order to fulfill security or compliance requirements.

As the hook runs on unauthenticated requests, malicious users can abuse the hook by calling it multiple times.  Pay extra care when using the hook as you can unintentionally block legitimate users from accessing your application.

Check if a password is valid prior to taking any additional action to ensure the user is legitimate. Instead of blocking further verification attempts, consider sending an email or notification to an administrator via a trigger instead.

### Inputs

- `user_id` Unique identifier for the user attempting to sign in. Correlate this to the `auth.users` table.
- `valid` Whether the password verification attempt was valid.

```json
{
	"user_id": "3919cb6e-4215-4478-a960-6d3454326cec",
	"valid": true,
}
```

### Outputs

Return these only if your hook processed the input without errors.

- `decision` A string containing the decision whether to allow authentication to move forward. Use `reject` to completely reject the verification attempt and log the user out of all active sessions. Use `continue` to use the default Supabase Auth behavior.
- `message` The message to show the user if the decision was `reject`.
- `should_logout_user` Whether to logout a user if a `reject` decision is issued. Has no effect when a `continue` decision is issued.

Example output:

```json
{
   "decision": "reject",
   "message" : "You have exceeded maximum number of MFA attempts.",
   "should_logout_user": "false"
}
```

### Example: Limit Failed Password Verification Attempts

<Tabs
  scrollable
  size="small"
  type="underlined"
  defaultActiveId="js"
  queryGroup="language"
>
<TabPanel id="add-admin-role" label="Limit Failed Password Verification Attempts">

As part of new security measures within the company, users can only input an incorrect password every 10 seconds and not more than that. You are charged with impelementing a hook to enforce this.

#### Database Setup

First you need to create a table that will record the last time a user had an incorrect password verification attempt.

You can do this by creating a table such as:

```sql
create table public.password_failed_verification_attempts (
	user_id uuid not null,
  last_failed_at timestamp not null default now(),
  primary key (user_id)
);
```

Then you should create a hook which will read and enter information into this table. Example:

```sql
create function public.hook_password_verification_attempt(event jsonb)
returns jsonb
language plpgsql
as $$
	declare
		last_failed_at timestamp;
	begin
		if event->'valid' is true
		then
			-- code is valid, accept it
			return jsonb_build_object('decision', 'continue');
		end if;

		select last_failed_at into last_failed_at
			from public.password_failed_verification_attempts
			where
				user_id = event->'user_id'

		if last_failed_at is not null and now() - last_failed_at < interval '10 seconds'
		then
			-- last attempt was done too quickly
			return jsonb_build_object(
				'error', jsonb_build_object(
					'http_code', 429,
					'message',   'Please wait a moment before trying again.'));
		end if;

		-- record this failed attempt
		insert into public.password_failed_verification_attempts
			(
				user_id,
				last_failed_at
			)
			values
			(
				event->'user_id',
				now()
			)
			on conflict
        do update
          set last_failed_at = now();

		-- finally let Supabase Auth do the default behavior for a failed attempt
		return jsonb_build_object('decision', 'continue');
	end;
	$$;


-- Assign appropriate permissions
grant execute
	on function public.hook_password_verification_attempt
	to supabase_auth_admin;

grant all
	on table public.password_failed_verification_attempts
	to supabase_auth_admin;

revoke execute
	on function public.hook_password_verification_attempt
	from authenticated, anon;

revoke all
	on table public.password_failed_verification_attempts
	from authenticated, anon;
```
</TabPanel>
</Tabs>

## Custom Access Token Hook

The custom access token hook runs before a token is issued and allows you to add additional claims based on the authentication method used or add additional metadata to select users.

Claims returned must conform to our specification. Supabase Auth will check for these claims after the hook is run and return an error if they are not present.

Here's a listing of all fields currently available on an access token:

| Field           | Is Required Claim |
|-----------------|-------------------|
| `aud`           | Yes               |
| `exp`           | Yes               |
| `jti`           | No                |
| `iat`           | Yes               |
| `iss`           | No                |
| `nbf`           | No                |
| `sub`           | Yes               |
| `email`         | Yes               |
| `phone`         | Yes               |
| `app_metadata`  | No                |
| `user_metadata` | No                |
| `role`          | Yes               |
| `aal`           | Yes               |
| `amr`           | No                |
| `session_id`    | No                |


### Inputs

- `user_id`Unique identifier for the user attempting to sign in. Correlate this to the `auth.users` table.
- `claims` Claims which are attached to the access token.
- `authentication_method` the authentication method used to request the access token. Possible values include:
`oauth`, `password`, `otp`, `totp`, `recovery`, `invite`, `sso/saml`, `magiclink`, `email/signup`, `email_change`, `token_refresh`.



### Outputs

Return these only if your hook processed the input without errors.

- `claims` A json containing the updated claims after the hook has been run.

### Example: Add Custom Claims to Token

<Tabs
  scrollable
  size="small"
  type="underlined"
  defaultActiveId="js"
  queryGroup="language"
>
<TabPanel id="add-admin-role" label="Add Admin Role">

Your company would like to allow users with a `@supabase.com` email account to perform restricted actions. To support this, users who are registered as admins with the company should be accorded the `admin` role.

Create a hook which adds an additional role:

```sql
create or replace function public.custom_access_token_hook(event jsonb)
returns jsonb
language plpgsql
as $$
	declare
		claims jsonb;
		user_email text;
	begin
		-- Fetch the email based on user_id
		select email into user_email from users where id = event->>'user_id';

		-- Check if the email has suffix '@supabase.com'
		if user_email like '%@supabase.com' then
			claims := event->'claims';

			-- check if 'user_metadata' exists in claims
			if jsonb_typeof(claims->'user_metadata') is null then
				-- if 'user_metadata' does not exist, create an empty object
				claims := jsonb_set(claims, '{user_metadata}', '{}');
			end if;

			-- set a claim of 'admin'
			claims := jsonb_set(claims, '{user_metadata, admin}', 'true');

			-- update the 'claims' object in the original event
			event := jsonb_set(event, '{claims}', claims);
		end if;

		-- return the modified or original event
		return event;
	end;
$$;

grant execute
	on function public.custom_access_token_hook
	to supabase_auth_admin;

revoke execute
	on function public.custom_access_token_hook
	from authenticated, anon;
```
</TabPanel>

<TabPanel id="delete-usermetadata-claim" label="Delete Claims">
Your company would like to remove the user metadata claim in order to reduce the size of your access token.

```sql
create or replace function custom_access_token_delete_user_metadata(input jsonb)
returns jsonb as $$
declare
    result jsonb;
begin
    input := jsonb_set(input, '{claims}', (input->'claims') - 'user_metadata');
    result := jsonb_build_object('claims', input->'claims');
    return result;
end; $$ language plpgsql;

grant execute
	on function public.custom_access_token_delete_user_metadata
	to supabase_auth_admin;

revoke execute
	on function public.custom_access_token_delete_user_metadata
	from authenticated, anon;
```
</TabPanel>

</Tabs>



export const Page = ({ children }) => <Layout meta={meta} children={children} />
export default Page
